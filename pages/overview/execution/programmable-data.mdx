---
description:
---

import SimpleRiveViewer from "@/components/SimpleRiveViewer";

# Programmable data

With Programmable Data, smart contracts can access the entirety of onchain data. This allows developers to break free from the limitations of traditional EVM environments, where state storage is expensive and execution models are rigid.

<div className="mt-5">
	<SimpleRiveViewer
		src="/programmable-data/programmable-data.riv"
		width={850}
		height={300}
		stateMachine="Programmable Data"
	/>
</div>

Programmable Data unleashes developer creativity and enables new use cases previously inaccessible due to high state storage costs. Developers can now build fully onchain applications, where the UI, state, and all data are stored onchain.

This enables use cases previously impossible on a single blockchain, like decentralized social media platforms with onchain posts, and interactions that reward users with tokens based on their activity.

Decentralized Physical Infrastructure Networks (DePINs) can use Programmable Data to reward node operators based on their contributions, ensuring a robust decentralized network without centralized control. AI models can be stored and executed onchain, ensuring transparency and integrity.

Irys also supports a seamless deployment for a Data Availability (DA) layer, allowing users to encode their data, post it to Irys' storage layer, and receive rewards through a DA contract that processes sampling proofs.

## Cheap State

In typical EVM environments, storing state within smart contracts is expensive, limiting developers' ability to build complex applications. Programmable Data provides a more cost-effective solution by allowing contracts to use onchain data for verifiable compute. This significantly reduces costs, making it possible to maintain extensive and dynamic datasets.

## Flexible Execution Models

Programmable Data enables new execution models beyond direct interaction with Irys' VM including:

- Lazy evaluation, where actions are executed only when needed.
- Secure rollups, where execution results are published to the data layer.

This flexibility enables developers to optimize performance and security based on each specific use case.
